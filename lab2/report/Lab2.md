# 操作系统Lab2实验报告

## 一、实验目的
- 理解页表的建立和使用方法
- 理解物理内存的管理方法
- 理解页面分配算法

## 二、练习1：理解first-fit连续物理内存分配算法

### 1.1 First-Fit算法实现分析

#### 1.1.1 default_init函数
```c
static void default_init(void) {
    list_init(&free_list);
    nr_free = 0;
}
```
**功能**：初始化空闲页块链表，将空闲页数量设为0。这是物理内存管理的起始步骤。

#### 1.1.2 default_init_memmap函数
```c
static void default_init_memmap(struct Page *base, size_t n)
```
**功能**：初始化一个空闲内存块，具体步骤如下：

1. **初始化每个页面**：
   - 清空flags和property字段
   - 将引用计数ref设为0
   
2. **设置首页信息**：
   - 将base页的property设为n（表示连续空闲页数）
   - 设置PG_property标志位

3. **插入空闲链表**：
   - 按地址从低到高的顺序插入链表
   - 保证链表的有序性，便于后续合并操作

4. **更新统计信息**：
   - nr_free += n

**设计思想**：维护一个按地址排序的空闲页块链表，每个空闲块的首页记录连续空闲页数。

#### 1.1.3 default_alloc_pages函数
```c
static struct Page *default_alloc_pages(size_t n)
```
**分配流程**：

1. **检查可用性**：如果n > nr_free，返回NULL

2. **遍历空闲链表**：
   ```c
   while ((le = list_next(le)) != &free_list) {
       struct Page *p = le2page(le, page_link);
       if (p->property >= n) {
           page = p;
           break;  // 找到第一个满足的块就退出
       }
   }
   ```

3. **分割空闲块**（如果需要）：
   - 如果找到的块大小 > n，将剩余部分作为新的空闲块
   - 新块从(page + n)位置开始，大小为(property - n)

4. **更新状态**：
   - 从链表中删除或更新节点
   - nr_free -= n
   - 清除已分配页的PG_property标志

#### 1.1.4 default_free_pages函数
```c
static void default_free_pages(struct Page *base, size_t n)
```
**释放流程**：

1. **重置页面状态**：
   - 清空flags
   - 引用计数置0

2. **设置空闲块信息**：
   - base->property = n
   - 设置PG_property标志

3. **按地址顺序插入链表**：
   ```c
   while ((le = list_next(le)) != &free_list) {
       struct Page* page = le2page(le, page_link);
       if (base < page) {
           list_add_before(le, &(base->page_link));
           break;
       }
   }
   ```

4. **合并相邻空闲块**：
   - **向前合并**：检查前一个块是否与当前块物理地址连续
   ```c
   if (p + p->property == base) {
       p->property += base->property;
       ClearPageProperty(base);
       list_del(&(base->page_link));
       base = p;
   }
   ```
   - **向后合并**：检查后一个块是否与当前块连续
   ```c
   if (base + base->property == p) {
       base->property += p->property;
       ClearPageProperty(p);
       list_del(&(p->page_link));
   }
   ```

### 1.2 物理内存分配过程总结

1. **系统启动时**：page_init()检测可用物理内存，调用init_memmap()初始化空闲页块链表

2. **分配请求**：alloc_pages(n) → default_alloc_pages(n)
   - 遍历链表找第一个满足的块
   - 分割并返回

3. **释放请求**：free_pages(base, n) → default_free_pages(base, n)
   - 插入链表
   - 尝试合并相邻块

### 1.3 First-Fit算法的改进空间

#### 改进方向1：优化查找效率
**问题**：First-Fit每次分配都要从头遍历链表，时间复杂度O(n)

**改进方案**：
- **循环首次适应(Next Fit)**：记录上次分配位置，下次从该位置开始查找
- **分离空闲链表**：按大小范围维护多个链表（如：小块、中块、大块）
- **使用平衡树**：用红黑树或AVL树替代链表，按大小索引，查找O(log n)

#### 改进方向2：减少内存碎片
**问题**：First-Fit倾向于在低地址分配，造成大量小碎片

**改进方案**：
- **阈值策略**：小于某阈值的请求优先使用小块，避免分割大块
- **延迟合并**：不立即合并，等碎片积累到一定程度统一处理
- **伙伴系统**：按2的幂次分配和合并，减少外部碎片

#### 改进方向3：多核并发优化
**问题**：单一全局锁保护链表，多核竞争严重

**改进方案**：
- **Per-CPU缓存**：每个CPU维护本地空闲列表
- **分段锁**：将内存分区，每区独立锁
- **无锁数据结构**：使用CAS操作实现无锁链表

## 三、练习2：实现Best-Fit连续物理内存分配算法

### 3.1 Best-Fit算法设计思路

Best-Fit（最佳适应）算法的核心思想是：**在所有满足需求的空闲块中，选择大小最接近需求的块**，以最小化剩余空间，减少外部碎片。

### 3.2 代码实现说明

#### 3.2.1 初始化函数

```c
static free_area_t free_area;

#define free_list (free_area.free_list)
#define nr_free (free_area.nr_free)

static void best_fit_init(void) {
    list_init(&free_list);
    nr_free = 0;
}
```

**数据结构说明**：
- `free_area_t`结构体定义（位于memlayout.h）：
```c
typedef struct {
    list_entry_t free_list;    // 空闲块链表头
    unsigned int nr_free;       // 空闲页面总数
} free_area_t;
```
- `free_list`：双向循环链表的头节点，串联所有空闲内存块
- `nr_free`：记录当前所有空闲页面的总数，用于快速判断内存是否充足

**初始化流程**：
1. **`list_init(&free_list)`**：
   - 将链表初始化为空状态
   - 设置`free_list.prev = free_list.next = &free_list`
   - 形成自循环结构，表示空链表

2. **`nr_free = 0`**：
   - 清零空闲页面计数器
   - 后续每次`init_memmap`调用会累加可用页数

**作用**：为Best-Fit算法提供一个干净的初始环境，确保后续内存管理操作的正确性。

#### 3.2.2 内存映射初始化

```c
static void best_fit_init_memmap(struct Page *base, size_t n) {
    assert(n > 0);
    struct Page *p = base;
    
    // 步骤1：初始化每个页面的Page结构体
    for (; p != base + n; p ++) {
        assert(PageReserved(p));
        p->flags = p->property = 0;
        set_page_ref(p, 0);
    }
    
    // 步骤2：设置空闲块首页的属性
    base->property = n;
    SetPageProperty(base);
    nr_free += n;
    
    // 步骤3：按地址有序插入空闲链表
    if (list_empty(&free_list)) {
        list_add(&free_list, &(base->page_link));
    } else {
        list_entry_t* le = &free_list;
        while ((le = list_next(le)) != &free_list) {
            struct Page* page = le2page(le, page_link);
            
            if (base < page) {
                list_add_before(le, &(base->page_link));
                break;
            }
            else if (list_next(le) == &free_list) {
                list_add(le, &(base->page_link));
            }
        }
    }
}
```

**步骤1：初始化页面状态**

```c
for (; p != base + n; p ++) {
    assert(PageReserved(p));
    p->flags = p->property = 0;
    set_page_ref(p, 0);
}
```

- **遍历范围**：从`base`到`base + n - 1`，覆盖整个连续内存块
- **`assert(PageReserved(p))`**：
  - 验证页面之前被标记为Reserved（在page_init中设置）
  - 防止误操作已分配或正在使用的页面
- **`p->flags = p->property = 0`**：
  - 清除所有状态标志位（PG_reserved、PG_property等）
  - 将property字段归零（后续只有首页会设置此值）
- **`set_page_ref(p, 0)`**：
  - 引用计数清零，表示该页面未被任何虚拟页映射
  - 空闲页面的引用计数应始终为0

**步骤2：设置空闲块首页标记**

```c
base->property = n;
SetPageProperty(base);
nr_free += n;
```

- **`base->property = n`**：
  - 仅在首页记录连续空闲页数
  - Best-Fit算法通过此值判断块大小是否满足需求
  - 块内其他页面的property保持为0，避免歧义

- **`SetPageProperty(base)`**：
  - 宏定义：`set_bit(PG_property, &(base->flags))`
  - 将flags的PG_property位置1，标识此页为空闲块头页
  - 作用：快速区分普通页和块首页

- **`nr_free += n`**：
  - 全局计数器增加n个页面
  - 用于`best_fit_alloc_pages`中的快速检查：`if (n > nr_free) return NULL;`

**数据结构示例**：
```
空闲块（n=5）的内存布局：
┌─────────┬─────────┬─────────┬─────────┬─────────┐
│ Page 0  │ Page 1  │ Page 2  │ Page 3  │ Page 4  │
└─────────┴─────────┴─────────┴─────────┴─────────┘
property=5    =0        =0        =0        =0
PG_property=1 =0        =0        =0        =0
    ↑
   首页标记
```

**步骤3：有序插入空闲链表**

**情况1：链表为空**
```c
if (list_empty(&free_list)) {
    list_add(&free_list, &(base->page_link));
}
```
- 检查条件：`free_list.next == &free_list`
- 直接插入：`list_add`将base插入到头节点之后
- 结果：`[head] ↔ [base] ↔ [head]`

**情况2：链表非空，需按地址有序插入**

```c
list_entry_t* le = &free_list;
while ((le = list_next(le)) != &free_list) {
    struct Page* page = le2page(le, page_link);
    
    if (base < page) {
        list_add_before(le, &(base->page_link));
        break;
    }
    else if (list_next(le) == &free_list) {
        list_add(le, &(base->page_link));
    }
}
```

**遍历逻辑**：
- `le = &free_list`：从链表头开始
- `le = list_next(le)`：移动到下一个节点
- `le2page(le, page_link)`：从链表节点指针反推出Page结构体指针

**插入策略分析**：

**子情况A：找到插入位置（中间插入）**
```c
if (base < page) {
    list_add_before(le, &(base->page_link));
    break;
}
```
- **条件**：当前base的地址小于遍历到的page
- **操作**：在`le`之前插入base
- **示例**：
```
原链表：[head] ↔ [0x1000块] ↔ [0x3000块] ↔ [head]
插入base=0x2000：
     [head] ↔ [0x1000块] ↔ [0x2000块] ↔ [0x3000块] ↔ [head]
                            ↑
                        新插入位置
```
- **break退出**：找到位置后立即终止循环，避免重复插入

**子情况B：到达链表末尾（尾部插入）**
```c
else if (list_next(le) == &free_list) {
    list_add(le, &(base->page_link));
}
```
- **条件**：`list_next(le) == &free_list`表示le是最后一个有效节点
- **操作**：在le之后插入base（即链表尾部）
- **示例**：
```
原链表：[head] ↔ [0x1000块] ↔ [0x2000块] ↔ [head]
插入base=0x3000（最大地址）：
     [head] ↔ [0x1000块] ↔ [0x2000块] ↔ [0x3000块] ↔ [head]
                                        ↑
                                   尾部插入
```
- **注意**：此处不需要break，因为下一次循环`le = list_next(le)`会使`le == &free_list`，自然退出

**有序性的重要意义**：

1. **便于相邻块合并**：
```c
// 释放时判断是否可以合并
if (prev_block + prev_block->property == base) {
    // 地址连续，可以合并成一个大块
    prev_block->property += base->property;
}
```

2. **减少内存碎片**：
```
无序链表：[0x3000] → [0x1000] → [0x2000]
释放0x1500-0x2000时，无法快速发现可以与0x1000合并

有序链表：[0x1000] → [0x2000] → [0x3000]
释放0x1500-0x2000时，立即发现前驱是0x1000，可以合并
```

3. **提高查找效率**：
```c
// 在Best-Fit中虽然要遍历全部，但有序性让相邻块的比较更高效
// 在地址范围检查、调试输出时也更直观
```

**完整执行流程示例**：

假设系统检测到两块可用内存：
```
初始状态：free_list为空

第一次调用：init_memmap(pa2page(0x80200000), 512)
1. 初始化512个Page结构
2. base->property = 512, SetPageProperty(base)
3. nr_free = 512
4. list_empty() = true，直接插入
   结果：[head] ↔ [0x80200000, 512页] ↔ [head]

第二次调用：init_memmap(pa2page(0x80800000), 1024)  
1. 初始化1024个Page结构
2. base->property = 1024, SetPageProperty(base)  
3. nr_free = 512 + 1024 = 1536
4. 遍历链表：
   - le指向0x80200000块
   - base(0x80800000) > page(0x80200000)，继续
   - list_next(le) == &free_list，尾部插入
   结果：[head] ↔ [0x80200000, 512页] ↔ [0x80800000, 1024页] ↔ [head]

第三次调用：init_memmap(pa2page(0x80400000), 256)
1. 初始化256个Page结构
2. base->property = 256, SetPageProperty(base)
3. nr_free = 1536 + 256 = 1792  
4. 遍历链表：
   - le指向0x80200000块
   - base(0x80400000) > page(0x80200000)，继续
   - le指向0x80800000块  
   - base(0x80400000) < page(0x80800000)，在其前插入，break
   结果：[head] ↔ [0x80200000, 512页] ↔ [0x80400000, 256页] ↔ [0x80800000, 1024页] ↔ [head]
```

**边界条件处理**：

| 情况 | 检查机制 | 处理方式 |
|------|---------|---------|
| n=0 | `assert(n > 0)` | 断言失败，防止空块 |
| 页面已使用 | `assert(PageReserved(p))` | 断言失败，防止误操作 |
| 地址相等 | `if (base < page)` | 严格小于，相等时继续遍历至末尾 |
| 链表循环 | `while (le != &free_list)` | 头节点作为哨兵，不会死循环 |

**时间复杂度分析**：
- **初始化Page**：O(n)，遍历n个页面
- **插入链表**：O(m)，m为链表中已有块数
- **总复杂度**：O(n + m)

**关键设计思想**：
1. **首页标记法**：用property和PG_property标记块首，节省空间
2. **地址有序性**：简化合并逻辑，减少碎片
3. **全局计数**：nr_free快速判断，避免遍历链表
4. **断言保护**：多重检查确保状态一致性


#### 3.2.3 页面分配（核心改进）
```c
static struct Page *best_fit_alloc_pages(size_t n) {
    assert(n > 0);
    if (n > nr_free) {
        return NULL;
    }
    
    struct Page *page = NULL;
    list_entry_t *le = &free_list;
    size_t min_size = nr_free + 1; // 初始化为不可能的大值
    
    // 遍历整个链表，找最小满足块
    while ((le = list_next(le)) != &free_list) {
        struct Page *p = le2page(le, page_link);
        if (p->property >= n && p->property < min_size) {
            page = p;
            min_size = p->property;
        }
    }
    
    // 分割和更新（与First-Fit相同）
    if (page != NULL) {
        list_entry_t* prev = list_prev(&(page->page_link));
        list_del(&(page->page_link));
        if (page->property > n) {
            struct Page *p = page + n;
            p->property = page->property - n;
            SetPageProperty(p);
            list_add(prev, &(p->page_link));
        }
        nr_free -= n;
        ClearPageProperty(page);
    }
    return page;
}
```

**与First-Fit的区别**：
- First-Fit：找到第一个满足的块就返回（break）
- Best-Fit：遍历所有块，找最小的满足块（不break，持续更新min_size）

#### 3.2.4 页面释放
```c
static void best_fit_free_pages(struct Page *base, size_t n) {
    // 1. 重置页面状态
    for (p = base; p != base + n; p++) {
        assert(!PageReserved(p) && !PageProperty(p));
        p->flags = 0;
        set_page_ref(p, 0);
    }
    
    // 2. 设置空闲块信息
    base->property = n;
    SetPageProperty(base);
    nr_free += n;
    
    // 3. 按地址插入链表
    // (与First-Fit相同的插入逻辑)
    
    // 4. 向前合并
    le = list_prev(&(base->page_link));
    if (le != &free_list) {
        p = le2page(le, page_link);
        if (p + p->property == base) {
            p->property += base->property;
            ClearPageProperty(base);
            list_del(&(base->page_link));
            base = p;
        }
    }
    
    // 5. 向后合并
    le = list_next(&(base->page_link));
    if (le != &free_list) {
        p = le2page(le, page_link);
        if (base + base->property == p) {
            base->property += p->property;
            ClearPageProperty(p);
            list_del(&(p->page_link));
        }
    }
}
```

### 3.3 Best-Fit算法的改进空间

#### 改进方向1：优化查找性能
**当前问题**：每次分配都要遍历整个链表，时间复杂度O(n)

**改进方案**：
```
按大小维护有序链表或树结构：
- 使用平衡二叉搜索树（红黑树）：O(log n)查找
- 使用跳表(Skip List)：平均O(log n)，实现简单
- 分级索引：维护大小分级的哈希表
```

**示例：使用分级索引**
```c
// 按2的幂次分级：1-2页、3-4页、5-8页、9-16页...
#define MAX_ORDER 10
struct free_area_t free_areas[MAX_ORDER];

// 分配时快速定位：
int order = log2_ceil(n);
for (int i = order; i < MAX_ORDER; i++) {
    if (!list_empty(&free_areas[i])) {
        return alloc_from_order(i, n);
    }
}
```

#### 改进方向2：减少碎片
**当前问题**：Best-Fit虽然剩余空间最小，但容易产生大量微小碎片

**改进方案**：
- **阈值合并**：小于某阈值的碎片不单独使用，强制合并
- **分离式管理**：小对象用专门的小对象分配器（如SLAB）
- **Buddy System**：按2的幂次分配，合并简单高效

#### 改进方向3：自适应策略
```c
// 根据历史分配模式动态选择策略
struct alloc_stats {
    size_t avg_request_size;
    size_t fragmentation_ratio;
};

struct Page *adaptive_alloc(size_t n) {
    if (stats.avg_request_size < THRESHOLD) {
        return best_fit_alloc(n);  // 小对象用Best-Fit
    } else {
        return first_fit_alloc(n); // 大对象用First-Fit
    }
}
```

### 3.4 性能对比分析

| 指标 | First-Fit | Best-Fit |
|------|-----------|----------|
| 分配时间 | O(n)，找到即停 | O(n)，必须遍历 |
| 外部碎片 | 较多，低地址集中 | 理论更少 |
| 内存利用率 | 中等 | 较高 |
| 实际碎片情况 | 可能产生大碎片 | 易产生微小碎片 |
| 适用场景 | 请求大小差异大 | 请求大小相近 |

## 四、扩展练习Challenge：硬件的可用物理内存范围的获取方法

### 4.1 问题背景与挑战

在现代计算机系统中，物理内存布局远比我们想象的复杂。操作系统启动时面临的核心问题是：**如何知道哪些物理地址对应真实的RAM，哪些对应外设或保留区域？**

**典型的物理地址空间布局**：
```
0x00000000 ┌─────────────────────┐
           │   低端内存 (DOS)     │  640KB可用RAM
0x000A0000 ├─────────────────────┤
           │   VGA显存 (MMIO)    │  视频缓冲区
0x000C0000 ├─────────────────────┤
           │   BIOS ROM          │  固件代码
0x00100000 ├─────────────────────┤
           │                     │
           │   扩展内存 (RAM)    │  主要可用内存
           │                     │
0x80000000 ├─────────────────────┤
           │   PCI设备 (MMIO)    │  网卡、显卡等
0xE0000000 ├─────────────────────┤
           │   APIC/IOAPIC       │  中断控制器
0xFEC00000 ├─────────────────────┤
           │   保留区域          │
0xFFFFFFFF └─────────────────────┘
```

**问题的本质**：
- RAM区域分散且不连续（有空洞）
- MMIO区域占用物理地址但不是内存
- 错误访问非RAM区域会导致系统崩溃或硬件损坏
- OS无法通过"试探访问"来判断（风险太大）

### 4.2 解决方案：利用固件提供的内存映射表

#### 4.2.1 核心思想

**基本原理**：计算机启动时，固件（BIOS/UEFI）比操作系统更早运行，它可以直接与硬件通信，扫描内存控制器获取准确的内存布局信息。操作系统只需"问"固件要这份信息即可。

**信任链条**：
```
硬件真相 → 固件扫描 → 构建内存映射表 → 传递给OS → OS据此管理内存
```

#### 4.2.2 技术路线图

```
┌─────────────────────────────────────────────────────────────┐
│                    计算机上电启动流程                          │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
                    ┌──────────────────┐
                    │  硬件自检(POST)   │
                    │  检测内存大小     │
                    └──────────────────┘
                              │
                              ▼
                    ┌──────────────────┐
                    │  BIOS/UEFI固件   │
                    │  扫描内存控制器   │
                    └──────────────────┘
                              │
                              ▼
                    ┌──────────────────┐
                    │  构建内存映射表   │
                    │  - 起始地址       │
                    │  - 大小          │
                    │  - 类型(RAM/保留) │
                    └──────────────────┘
                              │
                              ▼
                    ┌──────────────────┐
                    │  传递方式:        │
                    │  ① E820中断      │
                    │  ② UEFI接口      │
                    │  ③ 设备树(DTB)   │
                    └──────────────────┘
                              │
                              ▼
                    ┌──────────────────┐
                    │  Bootloader读取  │
                    │  保存到约定位置   │
                    └──────────────────┘
                              │
                              ▼
                    ┌──────────────────┐
                    │  OS内核启动      │
                    │  解析内存映射表   │
                    └──────────────────┘
                              │
                              ▼
                    ┌──────────────────┐
                    │  建立物理内存管理 │
                    │  初始化页表       │
                    └──────────────────┘
```

### 4.3 方法深度解析：BIOS E820机制（x86架构经典方法）

#### 4.3.1 E820接口的工作原理

**接口概述**：E820是x86架构中BIOS提供的一个标准化中断服务，功能号为`INT 15h, AX=E820h`，用于查询系统地址映射。

**数据结构**：E820返回一系列内存区域描述符
```
每个条目包含：
┌─────────────────────────────────────┐
│  起始地址 (8字节)                    │  例如：0x0000000000100000
├─────────────────────────────────────┤
│  区域大小 (8字节)                    │  例如：0x000000001FF00000 (约511MB)
├─────────────────────────────────────┤
│  类型标识 (4字节)                    │  1=可用RAM, 2=保留, 3=ACPI...
├─────────────────────────────────────┤
│  扩展属性 (4字节)                    │  ACPI 3.0扩展信息
└─────────────────────────────────────┘
```

**内存类型分类**：
| 类型代码 | 名称 | 含义 | OS处理方式 |
|---------|------|------|-----------|
| 1 | E820_RAM | 可用内存 | 加入空闲页链表 |
| 2 | E820_RESERVED | 保留区域 | 标记为不可用 |
| 3 | E820_ACPI | ACPI数据表 | 解析后可回收 |
| 4 | E820_NVS | ACPI NVS | 永久保留 |
| 5 | E820_UNUSABLE | 损坏内存 | 标记为坏块 |

#### 4.3.2 调用流程示意图

```
Bootloader (实模式)
    │
    ├─ 1. 设置参数
    │     AX = E820h (功能号)
    │     EBX = 0 (首次调用)
    │     ECX = 24 (缓冲区大小)
    │     EDX = 'SMAP' (签名)
    │     ES:DI = 缓冲区地址
    │
    ├─ 2. 调用中断
    │     INT 15h
    │
    ├─ 3. 检查返回值
    │     EAX 应该 = 'SMAP'
    │     EBX = 延续ID (0表示结束)
    │     [ES:DI] = 填充的内存描述符
    │
    ├─ 4. 记录条目
    │     保存到预定内存位置
    │
    └─ 5. 循环调用
          直到 EBX = 0

最终结果：
内存0x8000位置存储了完整的E820映射表
```

#### 4.3.3 典型的E820映射表示例

**假设一台电脑的E820输出**：
```
条目1: [0x0000000000000000 - 0x000000000009FFFF] 类型1(RAM)      640KB
       └─ 低端内存，DOS兼容区域

条目2: [0x0000000000100000 - 0x000000007FFFFFFF] 类型1(RAM)      ~2GB
       └─ 主要可用内存

条目3: [0x00000000000A0000 - 0x00000000000FFFFF] 类型2(保留)     384KB
       └─ VGA显存和BIOS ROM

条目4: [0x0000000080000000 - 0x00000000DFFFFFFF] 类型2(保留)     1.5GB
       └─ PCI设备映射(MMIO)

条目5: [0x00000000FEC00000 - 0x00000000FECFFFFF] 类型2(保留)     1MB
       └─ IOAPIC寄存器

条目6: [0x0000000100000000 - 0x000000017FFFFFFF] 类型1(RAM)      2GB
       └─ 4GB以上的扩展内存
```

**图示内存布局**：
```
物理地址           类型        大小         用途
0GB     ┌────────────────┐
        │ ████ RAM       │  640KB    条目1: 可用
        ├────────────────┤
        │ ░░░░ 保留      │  384KB    条目3: BIOS/VGA
1MB     ├────────────────┤
        │                │
        │ ████ RAM       │  ~2GB     条目2: 主内存
        │                │
2GB     ├────────────────┤
        │ ░░░░ MMIO      │  1.5GB    条目4: 设备
3.5GB   ├────────────────┤
        │ ░░░░ 保留      │  0.5GB    空洞
4GB     ├────────────────┤
        │ ████ RAM       │  2GB      条目6: 高端内存
6GB     └────────────────┘

图例：████ = 可用RAM    ░░░░ = 保留/MMIO
```

### 4.4 OS内核如何使用这些信息

#### 4.4.1 信息传递机制

**Bootloader → Kernel的数据传递**：
```
约定的内存位置（示例）：
┌──────────────────────────────────┐
│ 0x00008000: E820条目数量          │  例如：6
├──────────────────────────────────┤
│ 0x00008004: 条目1                │  24字节
│ 0x0000801C: 条目2                │  24字节
│ 0x00008034: 条目3                │  24字节
│ ...                              │
└──────────────────────────────────┘

或通过寄存器传递（RISC-V）：
- a0: 硬件线程ID
- a1: 设备树(DTB)物理地址
```

#### 4.4.2 内核解析流程

**步骤1：读取映射表**
```
┌─────────────────────┐
│ pmm_init()          │
│   ↓                 │
│ detect_memory()     │
│   ↓                 │
│ 读取E820条目数      │
│ 遍历所有条目        │
└─────────────────────┘
```

**步骤2：分类处理**
```
for (每个E820条目) {
    if (类型 == RAM) {
        ┌──────────────────────┐
        │ 1. 页对齐            │  起始地址向上取整
        │ 2. 避开内核占用      │  跳过[0x80200000, end)
        │ 3. 调用init_memmap() │  加入空闲链表
        └──────────────────────┘
    }
    else if (类型 == ACPI) {
        ┌──────────────────────┐
        │ 解析ACPI表           │
        │ 标记为临时保留       │
        │ 解析完可回收         │
        └──────────────────────┘
    }
    else {
        ┌──────────────────────┐
        │ 标记为永久保留       │
        │ 不加入空闲链表       │
        └──────────────────────┘
    }
}
```

**步骤3：建立Page数组映射**
```
假设E820报告：
- [0x80200000 - 0x88000000] 128MB可用

内核处理：
┌─────────────────────────────────────┐
│ 1. 分配Page数组                      │
│    pages[0..32767]                  │  128MB / 4KB = 32768页
│                                     │
│ 2. 初始化每个Page                   │
│    for (i=0; i<32768; i++) {       │
│        pages[i].flags = 0;         │
│        pages[i].ref = 0;           │
│    }                               │
│                                     │
│ 3. 构建空闲链表                     │
│    init_memmap(pages, 32768)       │
│    按Best-Fit规则插入链表           │
└─────────────────────────────────────┘
```

### 4.5 现代系统的演进：UEFI与设备树

#### 4.5.1 UEFI方法的改进

**相比E820的优势**：
```
┌─────────────────┬────────────────┬────────────────┐
│     特性        │   E820 (旧)    │  UEFI (新)     │
├─────────────────┼────────────────┼────────────────┤
│ 接口方式        │ BIOS中断       │ 函数调用       │
│ 数据丰富度      │ 基本信息       │ 详细属性       │
│ 内存类型        │ 5种            │ 15+种          │
│ 64位支持        │ 需扩展         │ 原生支持       │
│ 可扩展性        │ 有限           │ 灵活           │
└─────────────────┴────────────────┴────────────────┘
```

**UEFI内存映射的额外信息**：
- 虚拟地址映射（用于运行时服务）
- 内存属性（可缓存、写保护等）
- 启动服务代码/数据（可回收）
- 运行时服务代码/数据（永久保留）

#### 4.5.2 设备树(DTB)方法（ARM/RISC-V）

**设备树的内存节点示例**：
```
设备树结构（简化）：
/
├── memory@80000000
│   ├── device_type = "memory"
│   ├── reg = <0x80000000 0x8000000>  // 起始地址, 大小
│   
├── reserved-memory
│   ├── opensbi@80000000
│   │   └── reg = <0x80000000 0x200000>  // OpenSBI占用
│   └── kernel@80200000
│       └── reg = <0x80200000 0x...>     // 内核占用
```

**RISC-V启动流程中的DTB传递**：
```
OpenSBI (M-Mode)
    │
    │ 扫描硬件，构建DTB
    │ 
    ├─ 将DTB放在固定物理地址
    │
    ├─ 设置寄存器：
    │    a0 = 当前hart ID
    │    a1 = DTB物理地址
    │
    └─ 跳转到内核入口(S-Mode)

Kernel (S-Mode)
    │
    ├─ 从a1寄存器读取DTB地址
    │
    ├─ 验证DTB魔数(0xd00dfeed)
    │
    ├─ 解析/memory节点
    │    提取起始地址和大小
    │
    └─ 调用pmm_init()初始化
```

### 4.6 实际案例：本实验中的实现

**实验中的简化方法（基于DTB）**：

```
┌─────────────────────────────────────────────┐
│ kern/driver/dtb.c                           │
├─────────────────────────────────────────────┤
│                                             │
│ void dtb_init(void) {                       │
│   1. 从boot_dtb读取DTB地址 (a1传入)         │
│   2. 转换为虚拟地址                          │
│   3. 验证DTB魔数                            │
│   4. 解析/memory节点                        │
│      - 提取base地址                         │
│      - 提取size大小                         │
│   5. 保存到全局变量                          │
│      memory_base = 0x80000000              │
│      memory_size = 0x8000000 (128MB)       │
│ }                                           │
│                                             │
└─────────────────────────────────────────────┘
                    │
                    ▼
┌─────────────────────────────────────────────┐
│ kern/mm/pmm.c                               │
├─────────────────────────────────────────────┤
│                                             │
│ static void page_init(void) {               │
│   1. 调用get_memory_base/size()            │
│   2. 计算可用范围                           │
│      [0x80200000, 0x88000000)              │
│      跳过OpenSBI和内核占用                  │
│   3. 分配Page数组                           │
│   4. 调用init_memmap()                     │
│      将空闲页加入链表                       │
│ }                                           │
│                                             │
└─────────────────────────────────────────────┘
```

### 4.7 方法对比与总结

#### 4.7.1 三种主流方法对比

| 方法 | 适用架构 | 获取时机 | 接口复杂度 | 信息丰富度 | 可靠性 |
|------|---------|---------|-----------|-----------|--------|
| **E820中断** | x86 | Bootloader实模式 | 简单 | 基本 | 高 |
| **UEFI接口** | x86/ARM/RISC-V | UEFI启动阶段 | 中等 | 丰富 | 很高 |
| **设备树(DTB)** | ARM/RISC-V | 固件传递 | 简单 | 中等 | 高 |

#### 4.7.2 关键设计要点

**通用原则**：
1. **信任链**：OS信任固件提供的信息（固件更接近硬件真相）
2. **标准化**：使用工业标准接口，保证兼容性
3. **保守处理**：对可疑区域宁可标记为保留，不冒险使用
4. **分层设计**：固件负责探测，OS负责管理

**安全考虑**：
```
┌─────────────────────────────────────┐
│ 防御性编程措施                       │
├─────────────────────────────────────┤
│ ✓ 验证魔数/签名                     │
│ ✓ 检查地址对齐                      │
│ ✓ 过滤重叠区域                      │
│ ✓ 保留内核占用区                    │
│ ✓ 边界检查（防止溢出）              │
│ ✓ 日志记录（便于调试）              │
└─────────────────────────────────────┘
```

#### 4.7.3 总结

获取可用物理内存范围的核心方法是**利用固件提供的内存映射信息**：

1. **启动阶段**：固件（BIOS/UEFI/OpenSBI）扫描硬件，构建内存映射表
2. **信息传递**：通过中断、函数调用或设备树将信息传给OS
3. **内核解析**：OS读取映射表，分类处理各类型区域
4. **建立管理**：初始化Page结构体，构建空闲链表

这种方法**可靠、标准化、跨平台**，是现代操作系统的主流选择。相比于"探测式"访问内存，固件提供的信息避免了硬件损坏风险，且能准确区分RAM、MMIO和保留区域。


## 五、重要知识点总结

### 5.1 本实验涉及的重要知识点

#### 知识点1：物理内存管理
**实验体现**：Page结构体、空闲链表管理
**原理对应**：连续内存分配、分页存储管理
**理解**：
- 实验中Page结构体是物理页框的抽象，对应原理中的"页框"概念
- 空闲链表是实现First-Fit/Best-Fit等算法的数据结构
- 差异：实验简化了很多细节，如未涉及页框回收策略、内存压缩等

#### 知识点2：页表机制
**实验体现**：三级页表、页表项结构、satp寄存器
**原理对应**：虚拟内存、地址转换、TLB
**理解**：
- Sv39页表是RISC-V的具体实现，对应原理中的"多级页表"
- 页表项的V、R、W、X位对应原理中的"页面保护"机制
- TLB加速是硬件实现，实验中通过sfence.vma指令刷新

#### 知识点3：地址空间
**实验体现**：虚拟地址0xFFFFFFFFC0200000映射到物理地址0x80200000
**原理对应**：虚拟地址空间、物理地址空间、地址映射
**理解**：
- 虚拟地址空间为每个进程提供独立的地址视图
- 通过页表实现虚实地址转换
- 差异：实验只建立了内核的映射，未涉及用户进程地址空间

#### 知识点4：内存分配算法
**实验体现**：First-Fit、Best-Fit算法实现
**原理对应**：动态分区分配算法
**理解**：
- First-Fit：快速但易产生碎片
- Best-Fit：减少浪费但慢且可能产生微小碎片
- Worst-Fit、Buddy System是其他典型算法

#### 知识点5：内存碎片
**实验体现**：分配、释放、合并操作
**原理对应**：外部碎片、内部碎片
**理解**：
- 外部碎片：空闲但无法利用的内存
- 合并操作是减少外部碎片的关键
- 内部碎片：实验中未明显体现（按页分配，页内浪费）

### 5.2 OS原理中重要但实验未涉及的知识点

#### 1. 虚拟内存的页面置换算法
**原理内容**：FIFO、LRU、Clock、LFU等页面置换算法
**未涉及原因**：实验只涉及物理内存管理，未实现虚拟内存的换页功能
**重要性**：在内存不足时，如何选择牺牲页面是虚拟内存管理的核心

#### 2. 段式内存管理
**原理内容**：段表、段页式结合
**未涉及原因**：RISC-V架构不支持段式管理，只有页式
**重要性**：x86等架构中仍使用段式，理解段式有助于理解权限管理

#### 3. 内存压缩与碎片整理
**原理内容**：紧缩技术、relocatable代码
**未涉及原因**：实现复杂度高，需要硬件支持
**重要性**：移动设备等资源受限环境中很重要

#### 4. 共享内存与写时复制(COW)
**原理内容**：进程间共享页面、Copy-on-Write
**未涉及原因**：需要进程管理支持，后续实验涉及
**重要性**：提高内存利用率、加速fork等操作

#### 5. NUMA架构的内存管理
**原理内容**：Non-Uniform Memory Access、内存亲和性
**未涉及原因**：实验环境是单节点，无NUMA
**重要性**：多核服务器中性能优化的关键

#### 6. 大页(Huge Page)支持
**原理内容**：2MB、1GB大页，减少TLB miss
**未涉及原因**：实验只使用4KB页面
**重要性**：数据库、虚拟化等场景显著提升性能

#### 7. 内存热插拔
**原理内容**：动态增减物理内存
**未涉及原因**：需要硬件和ACPI支持
**重要性**：云计算、服务器热维护

#### 8. 内存带宽管理
**原理内容**：内存控制器调度、缓存一致性
**未涉及原因**：属于硬件层面
**重要性**：影响系统整体性能