
# 实验 4 报告



## 实验目的

- 熟悉进程控制块（PCB）结构及其初始化
- 理解内核线程创建（fork）过程中需要复制与分配的资源
- 实现进程切换（proc_run）并掌握中断和页表切换的配合
- 深入理解分页模式与页表项操作（get_pte）

---

## 练习 0：已有实验合并

要求：本实验依赖 lab2/lab3，请将你在 lab2、lab3 中的实现合并到 lab4 中 `LAB2`、`LAB3` 注释标注的位置。

你需要在此节中填写：

- 合并了哪些文件/函数（列出源文件与主要修改的函数名）
- 合并过程中遇到的问题与解决办法
- 简短说明如何验证合并是否成功（例如：`make qemu` 能正确启动或通过某些测试用例）

占位：在此粘贴/引用你在 lab2、lab3 中重要的代码片段（若太长可给出文件路径与关键函数摘录）。

---

## 练习 1：alloc_proc 的实现与说明

任务：在 `kern/process/proc.c` 中完成 `alloc_proc` 函数，对新分配的 `struct proc_struct` 做基本初始化。

请在此处填写你的实现说明：

- 设计与实现要点（例如：如何选择内核栈、如何初始化链表节点、初始化字段默认值等）
- 关键代码片段（可粘贴核心初始化代码）
- 测试与验证：如何证明 `alloc_proc` 正确分配并初始化了 PCB（例如：打印字段、使用调试断点、通过运行用例等）

问题回答：

1) 请说明 `proc_struct` 中 `struct context context` 和 `struct trapframe *tf` 成员的含义及在本实验中的作用。

- struct context context：

	- 含义：用于保存内核线程在上下文切换（`switch_to`）时需要保存的寄存器状态。它只包含必须由被调用者（callee-saved）保存的寄存器，在 RISC-V 中包括返回地址 `ra`、栈指针 `sp` 和 `s0-s11` 寄存器。
	- 在本实验中的作用：当进程 A 被切换出 CPU 时，其 `context` 结构中保存了它在内核态执行的断点。当 `switch_to` 函数被调用时，它会将当前 CPU 的 callee-saved 寄存器存入旧进程的 `context`，并从新进程的 `context` 中恢复寄存器。对于一个新创建的线程，它的 `context.ra` 被设置为 `forkret` 函数地址，`context.sp` 指向其内核栈顶，确保它第一次被调度时能正确启动。

- struct trapframe *tf：

	- 含义：`tf` 是一个指向陷阱帧（trapframe）的指针。陷阱帧保存了发生中断、异常或系统调用时，用户态（或内核态）的**所有**寄存器状态，包括通用寄存器 `x1-x31`、程序计数器 `epc` 和状态寄存器 `sstatus` 等。
	- 在本实验中的作用：`trapframe` 使得中断/异常处理结束后能精确返回到原来的执行流。在 `do_fork` 创建新内核线程时，`kernel_thread` 函数会预先设置一个 `trapframe`，其中 `epc` 指向内核线程的入口点（`kernel_thread_entry`），`s0` 和 `s1` 存放线程要执行的函数和参数。这个 `tf` 被复制到新线程的内核栈上，当新线程启动并执行 `forkrets` 时，就会利用 `tf` 恢复寄存器，最终跳转到 `epc` 指定的入口函数开始执行。同时，`tf` 也用于在父子进程间传递返回值（例如，子进程的 `a0` 寄存器被设置为 0）。

（可在此处补充你通过读代码或调试观察到的更具体细节，如哪些寄存器被包含、tf 在何处分配和使用等。）

---

## 练习 2：do_fork 的实现与说明

任务：在 `kern/process/proc.c` 中完成 `do_fork` 函数，实现为新内核线程分配资源并复制父进程状态。

请在此处填写你的实现说明：

- 设计与实现要点（建议按步骤写清楚）：
	1. 调用 `alloc_proc` 获得一个新的 PCB
	2. 为进程分配内核栈（例如：调用 `alloc_page` 或者 `kmalloc`，并设置 `kstack` 指针）
	3. 复制父进程的 trapframe 到子进程的 trapframe（或为内核线程设置初始 trapframe）
	4. 复制/设置进程上下文（将父进程的 `context` 中需要保存的寄存器复制到子进程的 `context`，并设置返回值寄存器等）
	5. 将子进程加入到全局进程链表（准备调度）并设置状态为可运行（RUNNABLE）
	6. 唤醒子进程（如果有需要）并返回 pid

- 关键代码片段（粘贴核心实现或路径参考）
- 测试与验证：如何创建内核线程并验证其运行（例如：在 `init` 中创建线程并观察输出、通过 gdb 断点或 qemu 串口输出）

问题回答：

1) ucore 是否确保每个新 fork 的线程有唯一的 id？请说明分析和理由。

- 说明要点（示例）：
	- ucore 中通常通过 `pid` 或 `proc_id` 字段记录进程 id。查看 `do_fork` 或 `alloc_proc` 中如何分配 pid（例如是否使用一个全局递增的 pid 分配器），如果使用全局自增且在分配时有锁或在关中断下操作，则能保证唯一性。否则可能存在并发问题导致重复。
	- 如果实验代码在分配 pid 时使用了互斥或禁中断保护并且 pid 溢出策略明确，则可以认为唯一；请在此处写出你查到的具体实现与结论。

（请在此处填入你对代码的观察与结论，举证关键代码行号或函数名。）

---

## 练习 3：proc_run 的实现与说明

任务：实现 `proc_run` 函数，将指定进程切换上 CPU。实现要点列在练习说明中。

请在此处填写你的实现说明：

- 设计要点与实现细节：
	- 检查目标进程是否等于当前进程（若相同无需切换）
	- 使用 `local_intr_save(intr_flag)` 禁止中断并保存之前中断状态
	- 更新 `current` 或类似的当前进程指针
	- 切换页表（调用 `lsatp` 或 `write_csr(satp, ...)` 等），并执行 `sfence.vma` 如需要
	- 调用 `switch_to(&old->context, &new->context)` 完成上下文切换
	- 恢复中断状态 `local_intr_restore(intr_flag)`

- 关键代码片段（粘贴核心实现或路径参考）
- 测试与验证：如何运行并观察进程调度行为（例如：运行 `make qemu`，在串口日志或 printk 输出看到多个内核线程被调度）

问题回答：

1) 在本实验执行过程中，创建且运行了几个内核线程？

- 请在此列出你实际创建并运行的线程数量与名称（例如：init 线程、若干 worker 线程、idle 线程等），并简要说明其作用与创建位置。

---

## 扩展练习（Challenge）

1) 请说明语句 `local_intr_save(intr_flag); ... local_intr_restore(intr_flag);` 是如何实现开关中断的？

		- 实现要点（参考 `kern/sync/sync.h`）：

			- `local_intr_save(x)` 实际调用 `__intr_save()`：该函数读取 CSR `sstatus`，检查其中的 `SSTATUS_SIE`（Supervisor Interrupt Enable）位。如果该位为 1（表示中断当前允许），`__intr_save()` 会调用 `intr_disable()` 关闭中断并返回 1；若该位为 0，则直接返回 0。`local_intr_save` 将返回值保存到 `intr_flag` 中，从而记录进入临界区前的中断状态。

			- `local_intr_restore(x)` 实际调用 `__intr_restore(x)`：该函数根据传入的 `intr_flag` 值决定是否调用 `intr_enable()` 恢复中断。只有当 `intr_flag` 为 1（进入前中断是开启的）时才重新开启中断；为 0 则保持关闭状态。

		- 为什么要保存并恢复（而不是简单调用 disable/enable）？

			- 保存/恢复机制能正确处理嵌套临界区。举例：若外层函数 A 在进入时保存到 `fa=1` 并关闭中断，内层函数 B 再次调用 `local_intr_save(fb)` 会得到 `fb=0`（因为中断已经被关闭），B 退出时执行 `local_intr_restore(fb)` 将不会开启中断，避免破坏 A 的临界区。只有 A 最外层的 `local_intr_restore(fa)` 会真正恢复中断。示例代码：

				```c
				void A() {
						local_intr_save(fa); // 若之前开启 -> 关闭，fa = 1
						...
						B();
						...
						local_intr_restore(fa); // 若 fa=1 恢复开启
				}

				void B() {
						local_intr_save(fb); // 之前已关闭 -> fb = 0
						...
						local_intr_restore(fb); // fb=0 不恢复
				}
				```

		- 具体实现依赖的原语：`intr_disable()`/`intr_enable()` 通常通过修改 `sstatus` CSR 的中断使能位（例如 SIE/SPIE）来关闭/开启本地中断；`__intr_save()`/`__intr_restore()` 只是对这些原语的薄封装并加入状态保存逻辑。

		- 小结：`local_intr_save/restore` 提供了一种保存-恢复式的本地中断屏蔽机制，能安全地进入临界区并在退出时恢复进入前的中断状态，避免因嵌套保护导致的中断错开问题。这是内核中实现短临界区和保护共享数据结构的常用模式。

2) 分页模式思考题：

- 比较 sv32、sv39、sv48：解释 `get_pte()` 中两段相似代码为什么相像（例如：因为多级页表的层数不同，但每层的处理流程相同：索引取位、检查 PTE、若需要则分配下一层页表等）。
- 是否应将页表查找与页表分配拆分为两个函数？给出你的理由（优缺点对比）。

---

## 知识点映射（实验 ↔ OS 原理）

请列出：

1) 在本实验中出现并且你认为重要的知识点，以及它们与操作系统原理中对应的知识点，写明含义、联系与区别。

- 示例模板（逐条填写）：
	- 实验知识点：进程控制块（PCB）初始化
		- OS 原理对应点：进程抽象与上下文切换
		- 含义：...（简述）
		- 关系与差异：...（如何在实验实现中体现，实验与理论的差异）

2) 在 OS 原理中重要但在本实验未覆盖的知识点（列举并说明为何未覆盖以及如何在后续实验或学习中补上）。

- 示例：虚拟内存高级管理（需求分页、段式管理、多级倒换策略）、复杂的进程间通信与同步原语、文件系统细节、完整的权限与安全模型等。

---

## 验证与运行（如何复现实验）

在仓库根目录下运行：

```bash
make qemu
```

或按实验提供的 Makefile 指引编译并在 qemu 中运行。请在此处填写你实际的编译与运行结果，包括串口输出或关键日志摘录。

---

## 总结与心得

在此简要总结你完成本次实验的收获、遇到的难点、以及下一步打算。

---

## 常见问题与调试提示

- 若出现链接或重定位错误，请检查 `kernel.ld` 与段定义是否一致。
- 若新进程无法运行，检查：是否正确设置 `context` 中的返回地址 `ra`、堆栈指针 `sp`、以及 `trapframe` 中的返回值寄存器。

---

## 附录：参考代码片段与关键函数位置

- `alloc_proc`：`lab4/kern/process/proc.c`
- `do_fork`：`lab4/kern/process/proc.c`
- `proc_run`：`lab4/kern/process/sched.c` 或 `proc.c`（视实现而定）
- `get_pte`：`lab4/kern/mm/pmm.c`

请按需在附录中粘贴你自己的关键代码实现以备查阅。

